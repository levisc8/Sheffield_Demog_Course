# Stochastic IPMs 
# 1/26/18
# Sam Levin
rm(list = ls())

source('R/WD_Paths.R')

rm(list=ls(all=TRUE))
set.seed(53241986)

## Working directory must be set here, so the source()'s below run
root=ifelse(.Platform$OS.type=="windows","C:/Users/sl13sise","~")
setwd(root)
setwd("Dropbox/ATSC 2018 participant folder/26.1.18/Stochasticity")

source("Carlina/Standard Graphical Pars.R");
source("Carlina/MatrixImage.R");
source("Carlina/Carlina Demog Funs DI.R") 

#####################################################################
# Load fitted parameter vectors for 20 year-to-year transitions 
# Here we use parameters from fixed-effects fitting,  
# generated by Carlina Fixed Effects Demog.R in Rcode/c7/Carlina 
#####################################################################
load("Carlina/Yearly parameters.Rdata")
params <- m.par.est; params; 

#####################################################################
# Make kernels for each year, and average kernel 
#####################################################################
nBigMatrix <- 100; minsize <- 1.5; maxsize <- 6; n.years <-20; 

# Estimates based on T=25000 years, dropping initial and final 1000
n.est <- 25000; n.runin <- 1000; 

######## Make kernels for each of the 20 observed transitions 
K.year.i <- array(NA,c(n.years,nBigMatrix,nBigMatrix))
for(i in 1:n.years){
  year.K<-mk_K(nBigMatrix,params[,i],minsize,maxsize)
  K.year.i[i,,] <- year.K$K
}

######## pull these out, for use in later calculations     
h <- year.K$h; meshpts <- year.K$meshpts    

######## Calculate mean kernel, its v and w
mean.kernel <- apply(K.year.i,2:3,mean)
mean.eigen <- eigen(mean.kernel); 
w <- Re(mean.eigen$vectors[,1]);
lambda1 <- abs(mean.eigen$values[1])
v <- Re(eigen(t(mean.kernel))$vectors[,1]);

######## Scale eigenvectors so that <v,w> = 1 
w <- abs(w)/sum(h*abs(w))
v <- abs(v); v <- v/(h*sum(v*w))
cat(h*sum(v*w)," should = 1","\n")

######## Elasticity of mean kernel (code from Chapter 4)       
meanK.sens <- outer(v, w, "*")/sum(v * w * h)
meanK.elas <- meanK.sens * (mean.kernel / h) / lambda1

####################################################
# Estimate lambda_S by kernel sampling 
####################################################
# Generate 20000 years, by sampling from the 20 we have 	
year.i <- sample(1:n.years,n.est+1,replace=TRUE)

# vector to hold year-specific r(t) = log lambda(t)
# based on total population N, or total reproductive value V      
rt.V <- rt.N <- rep(NA,n.est)

# initialize population vector 	
nt<-rep(1/nBigMatrix,nBigMatrix)

# Iterate model
for (year.t in 1:n.est){
  if(year.t%%1000==0) cat("iterate: ", year.t,"\n");
  nt1 <- K.year.i[year.i[year.t],,] %*% nt
  sum.nt1 <- sum(nt1)
  
  #Calculate log growth rates  
  rt.V[year.t] <- log(sum(nt1*v)/sum(nt*v))
  rt.N[year.t] <- log(sum(nt1)/sum(nt))
  nt <- nt1 / sum.nt1  
}

# Theory says rt.V should have no autocorrelation
graphics.off(); par(mfrow=c(2,1)); 
acf(rt.N,lag.max=20,type="partial",ylim=c(-0.1,0.1)); 
acf(rt.V,lag.max=20,type="partial",ylim=c(-0.1,0.1)); 

# compare amount of variation 
sd(rt.N); sd(rt.V); 

# use rt.V to estimate log(lambda_S) 
log_Ls <- mean(rt.V); Ls <- exp(log_Ls); 

####################################################
# Get the w(t) and v(t) series 
####################################################    

### Get w(t) by iterating forward in time 
wt <- matrix(1/nBigMatrix, nrow=n.est+1, ncol=nBigMatrix);
for (i in 1:n.est) {
  K  <- K.year.i[year.i[i],,]
  wt[i+1,]  <-K %*% wt[i,]
  wt[i+1,]  <-wt[i+1,]/sum(wt[i+1,]);
  if(i%%1000==0) cat("wt ",i,"\n")
}

### Get v(t) by iterating backwards in time ###
vt <- matrix(1/nBigMatrix, nrow=n.est+1, ncol=nBigMatrix);
for (i in (n.est+1):2) {
  K  <- K.year.i[year.i[i-1],,]
  vt[i-1,]  <- vt[i,] %*% K
  vt[i-1,]  <- vt[i-1,]/sum(vt[i-1,]);
  if(i%%1000==0) cat("vt  ",i,"\n")
}

###################################################################### 
# Compute sensitivities and elasticities using formulas in the table. 
# We estimate the averages in the formulas by summing over years, and 
# then divide by the total number of years 
######################################################################

sens.s <- elas.s <- matrix(0,nrow=nBigMatrix,ncol=nBigMatrix);
for (i in n.runin:(n.est-n.runin)) {
  K <-   K.year.i[year.i[i],,]
  
  vt1.wt <-   vt[i+1,]%*%t(wt[i,])
  vt1.K.wt <- sum(vt[i+1,] * (K %*% wt[i,]))
  
  sens.s <- sens.s + vt1.wt/vt1.K.wt;
  elas.s <- elas.s + K*(vt1.wt/vt1.K.wt);
  if(i%%1000==0) cat("elasticity ",i,"\n")
}

elas.s <- elas.s/(n.est-2*n.runin+1);
sens.s <- Ls*sens.s/(n.est-2*n.runin+1);
Kmean.elas <- mean.kernel * sens.s /Ls;
cat("sum elasticities = ",sum(elas.s)," should be 1");

######## Scale to densities (per-area sensitivities, instead of per-element) 
h.inv.2 = 1/(h^2); 
K.sens <- sens.s * h.inv.2;
K.elas <-  elas.s * h.inv.2;
K.mean.elas <- Kmean.elas * h.inv.2;
K.sd.elas <- K.elas - K.mean.elas;

PLOT <- FALSE; 
if(PLOT) {
  ############################################################################
  # Plotting as image/contour plots 
  ############################################################################
  ikeep <- which(meshpts>1.5 & meshpts<5) # use to extract a region to plot
  
  set_graph_pars("panel1"); par(cex.axis=1.3,cex.lab=1.3); 
  
  image(meshpts[ikeep], meshpts[ikeep], t(meanK.elas[ikeep,ikeep]),
        col=grey(seq(0.6, 1, length=100)),
        xlab="Size (t), z", ylab="Size (t+1), z\'")
  contour(meshpts[ikeep], meshpts[ikeep], t(meanK.elas[ikeep,ikeep]), 
          add=TRUE, levels=c(0.05,0.2,0.4),labcex=1.2)
  dev.copy2pdf(file="figures/CarlinaMeanKernelElas.pdf"); 
  
  image(meshpts[ikeep], meshpts[ikeep], t(K.elas[ikeep,ikeep]),
        col=grey(seq(0.6, 1, length=100)),
        xlab="Size (t), z", ylab="Size (t+1), z\'")
  contour(meshpts[ikeep], meshpts[ikeep], t(K.elas[ikeep,ikeep]), 
          add=TRUE,levels=c(0.05,0.2,0.4),labcex=1.2)
  dev.copy2pdf(file="figures/CarlinaStochElas.pdf");         
  
  image(meshpts[ikeep], meshpts[ikeep], t(K.mean.elas[ikeep,ikeep]),
        col=grey(seq(0.6, 1, length=100)),
        xlab="Size (t), z", ylab="Size (t+1), z\'")
  contour(meshpts[ikeep], meshpts[ikeep], t(K.mean.elas[ikeep,ikeep]), 
          add=TRUE,levels=c(0.1,0.4,0.8),labcex=1.2)
  dev.copy2pdf(file="figures/CarlinaKernelMeanElas.pdf");         
  
  image(meshpts[ikeep], meshpts[ikeep], t(K.sd.elas[ikeep,ikeep]),
        col=grey(seq(0.6, 1, length=100)),
        xlab="Size (t), z", ylab="Size (t+1), z\'")
  contour(meshpts[ikeep], meshpts[ikeep], t(K.sd.elas[ikeep,ikeep]), 
          add=TRUE,levels=c(-0.05,-0.2,-0.4),labcex=1.2)
  abline(v=1.5); abline(h=1.5); abline(h=5); abline(v=5); 
  dev.copy2pdf(file="figures/CarlinaKernelSDElas.pdf"); 
}
